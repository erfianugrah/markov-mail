/**
 * Live Production Testing Command
 *
 * Tests production API against a curated dataset of real-world fraud patterns
 * and legitimate emails. This is NOT circular testing - these are hand-crafted
 * test cases based on real fraud observations, not generated by our detectors.
 */

interface TestCase {
  email: string;
  expectedDecision: 'allow' | 'block' | 'warn';
  category: string;
  notes: string;
}

/**
 * Curated Test Dataset
 *
 * These are real-world patterns observed in production fraud scenarios,
 * NOT generated by our detection algorithms. Each case represents an actual
 * pattern type that fraudsters use or legitimate users create.
 */
const TEST_CASES: TestCase[] = [
  // === LEGITIMATE EMAILS (Should ALLOW) ===
  // Real names - common patterns
  { email: 'john.smith@gmail.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Common English name' },
  { email: 'sarah.johnson@outlook.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Common English name' },
  { email: 'michael.brown@yahoo.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Common English name' },
  { email: 'emily.davis@hotmail.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Common English name' },
  { email: 'david.wilson@protonmail.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Privacy-focused service' },

  // International names
  { email: 'maria.garcia@gmail.com', expectedDecision: 'allow', category: 'legit-international', notes: 'Spanish name' },
  { email: 'mohammed.ali@outlook.com', expectedDecision: 'allow', category: 'legit-international', notes: 'Arabic name' },
  { email: 'li.wei@163.com', expectedDecision: 'allow', category: 'legit-international', notes: 'Chinese name' },
  { email: 'yuki.tanaka@gmail.com', expectedDecision: 'allow', category: 'legit-international', notes: 'Japanese name' },
  { email: 'hans.mueller@gmx.de', expectedDecision: 'allow', category: 'legit-international', notes: 'German name' },

  // Professional emails
  { email: 'j.smith@company.com', expectedDecision: 'allow', category: 'legit-professional', notes: 'Professional initial format' },
  { email: 'contact@business.io', expectedDecision: 'allow', category: 'legit-professional', notes: 'Business contact' },
  { email: 'info@startup.com', expectedDecision: 'allow', category: 'legit-professional', notes: 'Info address' },
  { email: 'support@service.net', expectedDecision: 'allow', category: 'legit-professional', notes: 'Support address' },

  // Legitimate year patterns (birth years, etc.)
  { email: 'john.smith.1985@gmail.com', expectedDecision: 'allow', category: 'legit-year', notes: 'Birth year - legitimate' },
  { email: 'sarah1990@outlook.com', expectedDecision: 'allow', category: 'legit-year', notes: 'Birth year suffix' },
  { email: 'mike_1988@yahoo.com', expectedDecision: 'allow', category: 'legit-year', notes: 'Birth year with underscore' },

  // 2-digit birth years (common pattern)
  { email: 'sarah90@gmail.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Millennial birth year (1990)' },
  { email: 'michael85@yahoo.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Millennial birth year (1985)' },
  { email: 'jennifer75@outlook.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Gen X birth year (1975)' },
  { email: 'robert70@hotmail.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Gen X birth year (1970)' },

  // Legitimate number patterns
  { email: 'alice42@gmail.com', expectedDecision: 'allow', category: 'legit-number', notes: 'Random memorable number' },
  { email: 'bob007@outlook.com', expectedDecision: 'allow', category: 'legit-number', notes: 'Pop culture reference' },

  // === FRAUDULENT EMAILS (Should BLOCK) ===
  // Sequential patterns - clear bot behavior
  { email: 'user1@gmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential user1' },
  { email: 'user2@gmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential user2' },
  { email: 'user123@yahoo.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential user123' },
  { email: 'test001@outlook.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Leading zeros - bot pattern' },
  { email: 'account99@gmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential account' },
  { email: 'member456@hotmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential member' },

  // Dated patterns - temporal fraud indicators
  { email: 'user2025@gmail.com', expectedDecision: 'block', category: 'fraud-dated', notes: 'Current year - suspicious' },
  { email: 'test_jan2025@outlook.com', expectedDecision: 'block', category: 'fraud-dated', notes: 'Month and year' },
  { email: 'signup20250104@yahoo.com', expectedDecision: 'block', category: 'fraud-dated', notes: 'Full date stamp' },

  // Keyboard walks - laziness indicator
  { email: 'qwerty123@gmail.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'QWERTY keyboard walk' },
  { email: 'asdfgh@outlook.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'ASDFGH keyboard walk' },
  { email: 'zxcvbn@gmail.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'ZXCVBN keyboard walk' },
  { email: '123456789@yahoo.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'Numeric sequence' },

  // Gibberish - random character spam
  { email: 'xkjgh2k9qw@gmail.com', expectedDecision: 'block', category: 'fraud-gibberish', notes: 'Random character spam' },
  { email: 'asdfjkl123@outlook.com', expectedDecision: 'block', category: 'fraud-gibberish', notes: 'Gibberish pattern' },
  { email: 'zzz999xxx@gmail.com', expectedDecision: 'block', category: 'fraud-gibberish', notes: 'Repetitive gibberish' },

  // Disposable domains - temporary email services
  { email: 'test@tempmail.com', expectedDecision: 'block', category: 'fraud-disposable', notes: 'Tempmail service' },
  { email: 'user@guerrillamail.com', expectedDecision: 'block', category: 'fraud-disposable', notes: 'Guerrilla mail' },
  { email: 'signup@10minutemail.com', expectedDecision: 'block', category: 'fraud-disposable', notes: '10 minute mail' },
  { email: 'test@mailinator.com', expectedDecision: 'block', category: 'fraud-disposable', notes: 'Mailinator' },

  // Plus addressing abuse - same email, multiple accounts
  { email: 'john+test1@gmail.com', expectedDecision: 'allow', category: 'warn-plus', notes: 'Plus addressing (allowed but flagged)' },
  { email: 'sarah+spam@outlook.com', expectedDecision: 'allow', category: 'warn-plus', notes: 'Plus addressing abuse indicator' },

  // === EDGE CASES ===
  // Legitimate but suspicious
  { email: 'test@company.com', expectedDecision: 'allow', category: 'edge-test-legit', notes: 'Test account but corporate domain' },
  { email: 'admin@startup.io', expectedDecision: 'allow', category: 'edge-admin', notes: 'Admin account' },

  // High-risk TLDs but legitimate use
  { email: 'contact@business.xyz', expectedDecision: 'allow', category: 'edge-tld', notes: 'New gTLD but legitimate' },
  { email: 'info@company.top', expectedDecision: 'allow', category: 'edge-tld', notes: 'High-risk TLD but professional' },
];

interface TestResult {
  email: string;
  expected: string;
  actual: string;
  riskScore: number;
  reason: string;
  passed: boolean;
  category: string;
  notes: string;
  latency: number;
}

async function testEmail(
  email: string,
  endpoint: string
): Promise<{ decision: string; riskScore: number; reason: string; latency: number }> {
  const startTime = Date.now();

  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email }),
    });

    const latency = Date.now() - startTime;

    // Check for minimal response (403 Forbidden with headers)
    if (response.status === 403) {
      const decision = response.headers.get('x-fraud-decision') || 'block';
      const riskScore = parseFloat(response.headers.get('x-fraud-risk-score') || '0');
      const reason = response.headers.get('x-fraud-reason') || 'unknown';
      return { decision, riskScore, reason, latency };
    }

    // Full JSON response (from /validate endpoint or success)
    const data = await response.json() as any;

    if (response.ok) {
      // Success response (201/200)
      return {
        decision: data.decision || 'allow',
        riskScore: data.riskScore || 0,
        reason: data.message || 'allowed',
        latency,
      };
    } else {
      // Error response with JSON
      return {
        decision: 'block',
        riskScore: data.riskScore || 0,
        reason: data.reason || 'blocked',
        latency,
      };
    }
  } catch (error) {
    return {
      decision: 'error',
      riskScore: 0,
      reason: error instanceof Error ? error.message : 'Unknown error',
      latency: Date.now() - startTime,
    };
  }
}

function calculateMetrics(results: TestResult[]) {
  const totalTests = results.length;
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;

  const legitimateTests = results.filter(r => r.category.startsWith('legit'));
  const fraudTests = results.filter(r => r.category.startsWith('fraud'));

  const truePositives = fraudTests.filter(r => r.actual === 'block' && r.passed).length;
  const falseNegatives = fraudTests.filter(r => r.actual !== 'block').length;
  const trueNegatives = legitimateTests.filter(r => r.actual === 'allow' && r.passed).length;
  const falsePositives = legitimateTests.filter(r => r.actual === 'block').length;

  const accuracy = (passed / totalTests) * 100;
  const precision = truePositives / (truePositives + falsePositives) || 0;
  const recall = truePositives / (truePositives + falseNegatives) || 0;
  const f1Score = (2 * precision * recall) / (precision + recall) || 0;

  const avgLatency = results.reduce((sum, r) => sum + r.latency, 0) / results.length;

  return {
    totalTests,
    passed,
    failed,
    accuracy,
    truePositives,
    falsePositives,
    trueNegatives,
    falseNegatives,
    precision: precision * 100,
    recall: recall * 100,
    f1Score: f1Score * 100,
    avgLatency,
  };
}

async function runTests(endpoint: string, verbose: boolean) {
  console.log(`\nüß™ Running Live Production Tests`);
  console.log(`üìç Endpoint: ${endpoint}`);
  console.log(`üìä Total Test Cases: ${TEST_CASES.length}\n`);

  const results: TestResult[] = [];

  for (let i = 0; i < TEST_CASES.length; i++) {
    const testCase = TEST_CASES[i];
    process.stdout.write(`Testing ${i + 1}/${TEST_CASES.length}: ${testCase.email.padEnd(40)} `);

    const result = await testEmail(testCase.email, endpoint);
    const passed = result.decision === testCase.expectedDecision;

    results.push({
      email: testCase.email,
      expected: testCase.expectedDecision,
      actual: result.decision,
      riskScore: result.riskScore,
      reason: result.reason,
      passed,
      category: testCase.category,
      notes: testCase.notes,
      latency: result.latency,
    });

    console.log(passed ? '‚úÖ' : '‚ùå');

    if (verbose || !passed) {
      console.log(`  Expected: ${testCase.expectedDecision}, Got: ${result.decision}`);
      console.log(`  Risk Score: ${result.riskScore.toFixed(2)}, Reason: ${result.reason}`);
      console.log(`  Category: ${testCase.category}, Notes: ${testCase.notes}`);
      console.log(`  Latency: ${result.latency}ms\n`);
    }

    // Rate limiting: small delay between requests
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // Calculate and display metrics
  const metrics = calculateMetrics(results);

  console.log('\n' + '='.repeat(80));
  console.log('üìä TEST RESULTS');
  console.log('='.repeat(80));
  console.log(`\nOverall Performance:`);
  console.log(`  Total Tests:     ${metrics.totalTests}`);
  console.log(`  Passed:          ${metrics.passed} (${metrics.accuracy.toFixed(1)}%)`);
  console.log(`  Failed:          ${metrics.failed} (${(100 - metrics.accuracy).toFixed(1)}%)`);
  console.log(`  Avg Latency:     ${metrics.avgLatency.toFixed(0)}ms`);

  console.log(`\nConfusion Matrix:`);
  console.log(`  True Positives:  ${metrics.truePositives} (fraud correctly blocked)`);
  console.log(`  False Positives: ${metrics.falsePositives} (legit incorrectly blocked)`);
  console.log(`  True Negatives:  ${metrics.trueNegatives} (legit correctly allowed)`);
  console.log(`  False Negatives: ${metrics.falseNegatives} (fraud incorrectly allowed)`);

  console.log(`\nDetailed Metrics:`);
  console.log(`  Precision:       ${metrics.precision.toFixed(1)}% (of blocked, how many were actually fraud)`);
  console.log(`  Recall:          ${metrics.recall.toFixed(1)}% (of all fraud, how many we caught)`);
  console.log(`  F1 Score:        ${metrics.f1Score.toFixed(1)}% (harmonic mean)`);

  // Category breakdown
  console.log(`\n${'='.repeat(80)}`);
  console.log('üìã CATEGORY BREAKDOWN');
  console.log('='.repeat(80));

  const categories = [...new Set(results.map(r => r.category))];
  categories.sort();

  for (const category of categories) {
    const categoryResults = results.filter(r => r.category === category);
    const categoryPassed = categoryResults.filter(r => r.passed).length;
    const categoryTotal = categoryResults.length;
    const categoryAccuracy = (categoryPassed / categoryTotal) * 100;

    console.log(`\n${category}: ${categoryPassed}/${categoryTotal} (${categoryAccuracy.toFixed(0)}%)`);

    if (verbose) {
      for (const result of categoryResults) {
        const status = result.passed ? '‚úÖ' : '‚ùå';
        console.log(`  ${status} ${result.email} - ${result.actual} (score: ${result.riskScore.toFixed(2)})`);
      }
    }
  }

  // Failed tests
  const failedTests = results.filter(r => !r.passed);
  if (failedTests.length > 0) {
    console.log(`\n${'='.repeat(80)}`);
    console.log('‚ùå FAILED TESTS');
    console.log('='.repeat(80));

    for (const test of failedTests) {
      console.log(`\n${test.email}`);
      console.log(`  Category:  ${test.category}`);
      console.log(`  Expected:  ${test.expected}`);
      console.log(`  Got:       ${test.actual} (score: ${test.riskScore.toFixed(2)})`);
      console.log(`  Reason:    ${test.reason}`);
      console.log(`  Notes:     ${test.notes}`);
    }
  }

  console.log('\n');
}

// Export as default for CLI loader
export default async function (args: string[]) {
  // Parse options manually
  const options = {
    endpoint: 'https://fraud.erfi.dev/validate',
    verbose: false,
  };

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--endpoint' || args[i] === '-e') {
      options.endpoint = args[++i];
    } else if (args[i] === '--verbose' || args[i] === '-v') {
      options.verbose = true;
    } else if (args[i] === '--help' || args[i] === '-h') {
      console.log(`
Usage: npm run cli test:live [options]

Run live tests against production API with curated test cases.

These test cases are hand-crafted based on real-world fraud patterns,
NOT generated by our detection algorithms (avoiding circular validation).

Options:
  -e, --endpoint <url>   API endpoint to test (default: https://fraud.erfi.dev/validate)
  -v, --verbose          Show detailed output for all tests
  -h, --help            Show this help message

Examples:
  npm run cli test:live
  npm run cli test:live --verbose
  npm run cli test:live --endpoint https://fraud.erfi.dev/signup
      `);
      return;
    }
  }

  await runTests(options.endpoint, options.verbose);
}
