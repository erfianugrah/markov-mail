/**
 * Live Production Testing Command
 *
 * Tests production API against a curated dataset of real-world fraud patterns
 * and legitimate emails. This is NOT circular testing - these are hand-crafted
 * test cases based on real fraud observations, not generated by our detectors.
 */

interface TestCase {
  email: string;
  expectedDecision: 'allow' | 'block' | 'warn';
  category: string;
  notes: string;
}

/**
 * Curated Test Dataset
 *
 * These are real-world patterns observed in production fraud scenarios,
 * NOT generated by our detection algorithms. Each case represents an actual
 * pattern type that fraudsters use or legitimate users create.
 */
const TEST_CASES: TestCase[] = [
  // === LEGITIMATE EMAILS (Should ALLOW) ===
  // Real names - common patterns
  { email: 'person1@gmail.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Generic user pattern' },
  { email: 'user1@outlook.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Generic user pattern' },
  { email: 'person2@yahoo.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Generic user pattern' },
  { email: 'user2@hotmail.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Generic user pattern' },
  { email: 'person3@protonmail.com', expectedDecision: 'allow', category: 'legit-name', notes: 'Privacy-focused service' },

  // International names
  { email: 'person4@gmail.com', expectedDecision: 'allow', category: 'legit-international', notes: 'International user' },
  { email: 'user3@outlook.com', expectedDecision: 'allow', category: 'legit-international', notes: 'International user' },
  { email: 'person5@163.com', expectedDecision: 'allow', category: 'legit-international', notes: 'International user' },
  { email: 'user4@gmail.com', expectedDecision: 'allow', category: 'legit-international', notes: 'International user' },
  { email: 'person6@provider.de', expectedDecision: 'allow', category: 'legit-international', notes: 'International user' },

  // Professional emails
  { email: 'p.user@company.com', expectedDecision: 'allow', category: 'legit-professional', notes: 'Professional initial format' },
  { email: 'contact@business.io', expectedDecision: 'allow', category: 'legit-professional', notes: 'Business contact' },
  { email: 'info@startup.com', expectedDecision: 'allow', category: 'legit-professional', notes: 'Info address' },
  { email: 'support@service.net', expectedDecision: 'allow', category: 'legit-professional', notes: 'Support address' },

  // Legitimate year patterns (birth years, etc.)
  { email: 'person1.1985@gmail.com', expectedDecision: 'allow', category: 'legit-year', notes: 'Birth year - legitimate' },
  { email: 'user5.1990@outlook.com', expectedDecision: 'allow', category: 'legit-year', notes: 'Birth year suffix' },
  { email: 'person7_1988@yahoo.com', expectedDecision: 'allow', category: 'legit-year', notes: 'Birth year with underscore' },

  // 2-digit birth years (common pattern)
  { email: 'person8.90@gmail.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Millennial birth year (1990)' },
  { email: 'user6.85@yahoo.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Millennial birth year (1985)' },
  { email: 'person9.75@outlook.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Gen X birth year (1975)' },
  { email: 'user7.70@hotmail.com', expectedDecision: 'allow', category: 'legit-2digit-year', notes: '2-digit Gen X birth year (1970)' },

  // Legitimate number patterns
  { email: 'user9.42@gmail.com', expectedDecision: 'allow', category: 'legit-number', notes: 'Random memorable number' },
  { email: 'person11.007@outlook.com', expectedDecision: 'allow', category: 'legit-number', notes: 'Pop culture reference' },

  // === FRAUDULENT EMAILS (Should BLOCK) ===
  // Sequential patterns - clear bot behavior
  { email: 'user1@gmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential user1' },
  { email: 'user2@gmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential user2' },
  { email: 'user123@yahoo.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential user123' },
  { email: 'test001@outlook.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Leading zeros - bot pattern' },
  { email: 'account99@gmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential account' },
  { email: 'member456@hotmail.com', expectedDecision: 'block', category: 'fraud-sequential', notes: 'Sequential member' },

  // Dated patterns - temporal fraud indicators
  { email: 'user2025@gmail.com', expectedDecision: 'block', category: 'fraud-dated', notes: 'Current year - suspicious' },
  { email: 'test_jan2025@outlook.com', expectedDecision: 'block', category: 'fraud-dated', notes: 'Month and year' },
  { email: 'signup20250104@yahoo.com', expectedDecision: 'block', category: 'fraud-dated', notes: 'Full date stamp' },

  // Keyboard walks - laziness indicator
  { email: 'qwerty123@gmail.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'QWERTY keyboard walk' },
  { email: 'asdfgh@outlook.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'ASDFGH keyboard walk' },
  { email: 'zxcvbn@gmail.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'ZXCVBN keyboard walk' },
  { email: '123456789@yahoo.com', expectedDecision: 'block', category: 'fraud-keyboard', notes: 'Numeric sequence' },

  // Gibberish - random character spam
  { email: 'xkjgh2k9qw@gmail.com', expectedDecision: 'block', category: 'fraud-gibberish', notes: 'Random character spam' },
  { email: 'asdfjkl123@outlook.com', expectedDecision: 'block', category: 'fraud-gibberish', notes: 'Gibberish pattern' },
  { email: 'zzz999xxx@gmail.com', expectedDecision: 'block', category: 'fraud-gibberish', notes: 'Repetitive gibberish' },

  // Disposable domains - temporary email services
  { email: 'test@tempmail.com', expectedDecision: 'block', category: 'fraud-disposable', notes: 'Tempmail service' },
  { email: 'user@guerrillamail.com', expectedDecision: 'block', category: 'fraud-disposable', notes: 'Guerrilla mail' },
  { email: 'signup@10minutemail.com', expectedDecision: 'block', category: 'fraud-disposable', notes: '10 minute mail' },
  { email: 'test@mailinator.com', expectedDecision: 'block', category: 'fraud-disposable', notes: 'Mailinator' },

  // Plus addressing abuse - same email, multiple accounts
  { email: 'person10+test1@gmail.com', expectedDecision: 'allow', category: 'warn-plus', notes: 'Plus addressing (allowed but flagged)' },
  { email: 'user8+spam@outlook.com', expectedDecision: 'allow', category: 'warn-plus', notes: 'Plus addressing abuse indicator' },

  // === EDGE CASES ===
  // Legitimate but suspicious
  { email: 'test@company.com', expectedDecision: 'allow', category: 'edge-test-legit', notes: 'Test account but corporate domain' },
  { email: 'admin@startup.io', expectedDecision: 'allow', category: 'edge-admin', notes: 'Admin account' },

  // High-risk TLDs but legitimate use
  { email: 'contact@business.xyz', expectedDecision: 'allow', category: 'edge-tld', notes: 'New gTLD but legitimate' },
  { email: 'info@company.top', expectedDecision: 'allow', category: 'edge-tld', notes: 'High-risk TLD but professional' },

  // === OUT-OF-DISTRIBUTION (OOD) DETECTION TESTS (v2.4+) ===
  // These test cases specifically target the OOD detection system, which identifies
  // patterns that are unfamiliar to BOTH fraud and legitimate models (high entropy on both).
  // Expected: WARN or BLOCK depending on how far above the OOD threshold (3.0 nats)

  // Severe OOD - very high entropy (> 4.0 nats) - should WARN or BLOCK
  { email: 'inearkstioarsitm2mst@gmail.com', expectedDecision: 'warn', category: 'ood-severe', notes: 'Anagram shuffle - very high entropy (H~4.45)' },
  { email: 'oarnimstiaremtn@gmail.com', expectedDecision: 'warn', category: 'ood-severe', notes: 'Random anagram - high entropy on both models' },
  { email: 'aremtinsoartmsient@gmail.com', expectedDecision: 'warn', category: 'ood-severe', notes: 'Long anagram pattern - abnormal structure' },
  { email: 'rtmaenisoartmstien@outlook.com', expectedDecision: 'warn', category: 'ood-severe', notes: 'Cross-shuffle pattern - unfamiliar transitions' },
  { email: 'ksjdnfpqowiemznxc@gmail.com', expectedDecision: 'warn', category: 'ood-severe', notes: 'Novel gibberish - not in training distribution' },

  // Moderate OOD - above threshold but not extreme (3.0-4.0 nats) - should WARN
  { email: 'inearkstioaermst@gmail.com', expectedDecision: 'warn', category: 'ood-moderate', notes: 'Moderate entropy anagram (H~3.99)' },
  { email: 'armentsiorast@gmail.com', expectedDecision: 'warn', category: 'ood-moderate', notes: 'Moderate shuffle - above OOD threshold' },
  { email: 'nmraoestinart@outlook.com', expectedDecision: 'warn', category: 'ood-moderate', notes: 'Mixed consonant-vowel pattern' },
  { email: 'trnaeoimsart@yahoo.com', expectedDecision: 'warn', category: 'ood-moderate', notes: 'Unfamiliar character transitions' },

  // Near-threshold OOD (just above 3.0) - should WARN or ALLOW depending on other signals
  { email: 'marinestone@gmail.com', expectedDecision: 'allow', category: 'ood-near-threshold', notes: 'Unusual but plausible word combo - borderline' },
  { email: 'artemisnor@outlook.com', expectedDecision: 'allow', category: 'ood-near-threshold', notes: 'Name-like but uncommon - near threshold' },
  { email: 'stormarine@gmail.com', expectedDecision: 'allow', category: 'ood-near-threshold', notes: 'Plausible compound - just above threshold' },

  // Cross-language mixing - tests OOD with international patterns
  { email: 'userÁî®Êà∑test@gmail.com', expectedDecision: 'allow', category: 'ood-cross-language', notes: 'Mixed Latin/Chinese - uncommon but valid' },
  { email: 'email„ÉÜ„Çπ„Éà123@outlook.com', expectedDecision: 'allow', category: 'ood-cross-language', notes: 'Mixed Latin/Japanese - valid use case' },

  // Novel bot patterns not in training data
  { email: 'acc_20250110_x7f@gmail.com', expectedDecision: 'block', category: 'ood-novel-bot', notes: 'New bot pattern - date + suffix' },
  { email: 'usr#20250110#a1b@outlook.com', expectedDecision: 'block', category: 'ood-novel-bot', notes: 'Novel delimiter pattern' },
  { email: 'id||2025||001@gmail.com', expectedDecision: 'block', category: 'ood-novel-bot', notes: 'Unusual separator style' },

  // Edge case: Low entropy (familiar patterns) - should NOT trigger OOD
  { email: 'person12@gmail.com', expectedDecision: 'allow', category: 'ood-low-entropy', notes: 'Common pattern - low entropy, no OOD' },
  { email: 'user13@outlook.com', expectedDecision: 'allow', category: 'ood-low-entropy', notes: 'Familiar pattern - should not trigger OOD' },
  { email: 'test@company.com', expectedDecision: 'allow', category: 'ood-low-entropy', notes: 'Standard pattern - low entropy baseline' },
];

interface TestResult {
  email: string;
  expected: string;
  actual: string;
  riskScore: number;
  reason: string;
  passed: boolean;
  category: string;
  notes: string;
  latency: number;
  // OOD Detection fields (v2.4+)
  minEntropy?: number;
  abnormalityScore?: number;
  abnormalityRisk?: number;
  oodDetected?: boolean;
}

async function testEmail(
  email: string,
  endpoint: string
): Promise<{
  decision: string;
  riskScore: number;
  reason: string;
  latency: number;
  minEntropy?: number;
  abnormalityScore?: number;
  abnormalityRisk?: number;
  oodDetected?: boolean;
}> {
  const startTime = Date.now();

  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email }),
    });

    const latency = Date.now() - startTime;

    // Check for minimal response (403 Forbidden with headers)
    if (response.status === 403) {
      const decision = response.headers.get('x-fraud-decision') || 'block';
      const riskScore = parseFloat(response.headers.get('x-fraud-risk-score') || '0');
      const reason = response.headers.get('x-fraud-reason') || 'unknown';
      return { decision, riskScore, reason, latency };
    }

    // Full JSON response (from /validate endpoint or success)
    const data = await response.json() as any;

    if (response.ok) {
      // Success response (201/200)
      return {
        decision: data.decision || 'allow',
        riskScore: data.riskScore || 0,
        reason: data.message || 'allowed',
        latency,
        // OOD Detection fields (v2.4+)
        minEntropy: data.signals?.minEntropy,
        abnormalityScore: data.signals?.abnormalityScore,
        abnormalityRisk: data.signals?.abnormalityRisk,
        oodDetected: data.signals?.oodDetected,
      };
    } else {
      // Error response with JSON
      return {
        decision: 'block',
        riskScore: data.riskScore || 0,
        reason: data.reason || 'blocked',
        latency,
        minEntropy: data.signals?.minEntropy,
        abnormalityScore: data.signals?.abnormalityScore,
        abnormalityRisk: data.signals?.abnormalityRisk,
        oodDetected: data.signals?.oodDetected,
      };
    }
  } catch (error) {
    return {
      decision: 'error',
      riskScore: 0,
      reason: error instanceof Error ? error.message : 'Unknown error',
      latency: Date.now() - startTime,
    };
  }
}

function calculateMetrics(results: TestResult[]) {
  const totalTests = results.length;
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;

  const legitimateTests = results.filter(r => r.category.startsWith('legit'));
  const fraudTests = results.filter(r => r.category.startsWith('fraud'));

  const truePositives = fraudTests.filter(r => r.actual === 'block' && r.passed).length;
  const falseNegatives = fraudTests.filter(r => r.actual !== 'block').length;
  const trueNegatives = legitimateTests.filter(r => r.actual === 'allow' && r.passed).length;
  const falsePositives = legitimateTests.filter(r => r.actual === 'block').length;

  const accuracy = (passed / totalTests) * 100;
  const precision = truePositives / (truePositives + falsePositives) || 0;
  const recall = truePositives / (truePositives + falseNegatives) || 0;
  const f1Score = (2 * precision * recall) / (precision + recall) || 0;

  const avgLatency = results.reduce((sum, r) => sum + r.latency, 0) / results.length;

  return {
    totalTests,
    passed,
    failed,
    accuracy,
    truePositives,
    falsePositives,
    trueNegatives,
    falseNegatives,
    precision: precision * 100,
    recall: recall * 100,
    f1Score: f1Score * 100,
    avgLatency,
  };
}

async function runTests(endpoint: string, verbose: boolean) {
  console.log(`\nüß™ Running Live Production Tests`);
  console.log(`üìç Endpoint: ${endpoint}`);
  console.log(`üìä Total Test Cases: ${TEST_CASES.length}\n`);

  const results: TestResult[] = [];

  for (let i = 0; i < TEST_CASES.length; i++) {
    const testCase = TEST_CASES[i];
    process.stdout.write(`Testing ${i + 1}/${TEST_CASES.length}: ${testCase.email.padEnd(40)} `);

    const result = await testEmail(testCase.email, endpoint);
    const passed = result.decision === testCase.expectedDecision;

    results.push({
      email: testCase.email,
      expected: testCase.expectedDecision,
      actual: result.decision,
      riskScore: result.riskScore,
      reason: result.reason,
      passed,
      category: testCase.category,
      notes: testCase.notes,
      latency: result.latency,
      // OOD Detection fields (v2.4+)
      minEntropy: result.minEntropy,
      abnormalityScore: result.abnormalityScore,
      abnormalityRisk: result.abnormalityRisk,
      oodDetected: result.oodDetected,
    });

    console.log(passed ? '‚úÖ' : '‚ùå');

    if (verbose || !passed) {
      console.log(`  Expected: ${testCase.expectedDecision}, Got: ${result.decision}`);
      console.log(`  Risk Score: ${result.riskScore.toFixed(2)}, Reason: ${result.reason}`);
      if (result.oodDetected) {
        console.log(`  üö® OOD Detected: minEntropy=${result.minEntropy?.toFixed(2)}, abnormalityRisk=${result.abnormalityRisk?.toFixed(2)}`);
      }
      console.log(`  Category: ${testCase.category}, Notes: ${testCase.notes}`);
      console.log(`  Latency: ${result.latency}ms\n`);
    }

    // Rate limiting: small delay between requests
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // Calculate and display metrics
  const metrics = calculateMetrics(results);

  console.log('\n' + '='.repeat(80));
  console.log('üìä TEST RESULTS');
  console.log('='.repeat(80));
  console.log(`\nOverall Performance:`);
  console.log(`  Total Tests:     ${metrics.totalTests}`);
  console.log(`  Passed:          ${metrics.passed} (${metrics.accuracy.toFixed(1)}%)`);
  console.log(`  Failed:          ${metrics.failed} (${(100 - metrics.accuracy).toFixed(1)}%)`);
  console.log(`  Avg Latency:     ${metrics.avgLatency.toFixed(0)}ms`);

  console.log(`\nConfusion Matrix:`);
  console.log(`  True Positives:  ${metrics.truePositives} (fraud correctly blocked)`);
  console.log(`  False Positives: ${metrics.falsePositives} (legit incorrectly blocked)`);
  console.log(`  True Negatives:  ${metrics.trueNegatives} (legit correctly allowed)`);
  console.log(`  False Negatives: ${metrics.falseNegatives} (fraud incorrectly allowed)`);

  console.log(`\nDetailed Metrics:`);
  console.log(`  Precision:       ${metrics.precision.toFixed(1)}% (of blocked, how many were actually fraud)`);
  console.log(`  Recall:          ${metrics.recall.toFixed(1)}% (of all fraud, how many we caught)`);
  console.log(`  F1 Score:        ${metrics.f1Score.toFixed(1)}% (harmonic mean)`);

  // OOD Detection Statistics (v2.4+)
  const oodResults = results.filter(r => r.oodDetected);
  if (oodResults.length > 0) {
    console.log(`\nüö® OOD Detection Statistics (v2.4+):`);
    console.log(`  Total OOD Detected:    ${oodResults.length} of ${results.length} (${((oodResults.length / results.length) * 100).toFixed(1)}%)`);
    const avgMinEntropy = oodResults.reduce((sum, r) => sum + (r.minEntropy || 0), 0) / oodResults.length;
    const avgAbnormalityRisk = oodResults.reduce((sum, r) => sum + (r.abnormalityRisk || 0), 0) / oodResults.length;
    console.log(`  Avg minEntropy:        ${avgMinEntropy.toFixed(2)} nats (threshold: 3.0)`);
    console.log(`  Avg abnormalityRisk:   ${avgAbnormalityRisk.toFixed(2)} (0.0-0.6)`);
    console.log(`  OOD Categories:        ${[...new Set(oodResults.map(r => r.category))].join(', ')}`);
  }

  // Category breakdown
  console.log(`\n${'='.repeat(80)}`);
  console.log('üìã CATEGORY BREAKDOWN');
  console.log('='.repeat(80));

  const categories = [...new Set(results.map(r => r.category))];
  categories.sort();

  for (const category of categories) {
    const categoryResults = results.filter(r => r.category === category);
    const categoryPassed = categoryResults.filter(r => r.passed).length;
    const categoryTotal = categoryResults.length;
    const categoryAccuracy = (categoryPassed / categoryTotal) * 100;

    console.log(`\n${category}: ${categoryPassed}/${categoryTotal} (${categoryAccuracy.toFixed(0)}%)`);

    if (verbose) {
      for (const result of categoryResults) {
        const status = result.passed ? '‚úÖ' : '‚ùå';
        const oodInfo = result.oodDetected ? ` [OOD: ${result.minEntropy?.toFixed(2)}]` : '';
        console.log(`  ${status} ${result.email} - ${result.actual} (score: ${result.riskScore.toFixed(2)})${oodInfo}`);
      }
    }
  }

  // Failed tests
  const failedTests = results.filter(r => !r.passed);
  if (failedTests.length > 0) {
    console.log(`\n${'='.repeat(80)}`);
    console.log('‚ùå FAILED TESTS');
    console.log('='.repeat(80));

    for (const test of failedTests) {
      console.log(`\n${test.email}`);
      console.log(`  Category:  ${test.category}`);
      console.log(`  Expected:  ${test.expected}`);
      console.log(`  Got:       ${test.actual} (score: ${test.riskScore.toFixed(2)})`);
      console.log(`  Reason:    ${test.reason}`);
      if (test.oodDetected) {
        console.log(`  üö® OOD:    minEntropy=${test.minEntropy?.toFixed(2)}, abnormalityRisk=${test.abnormalityRisk?.toFixed(2)}`);
      }
      console.log(`  Notes:     ${test.notes}`);
    }
  }

  console.log('\n');
}

// Export as default for CLI loader
export default async function (args: string[]) {
  // Parse options manually
  const options = {
    endpoint: 'https://your-worker.workers.dev/validate',
    verbose: false,
  };

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--endpoint' || args[i] === '-e') {
      options.endpoint = args[++i];
    } else if (args[i] === '--verbose' || args[i] === '-v') {
      options.verbose = true;
    } else if (args[i] === '--help' || args[i] === '-h') {
      console.log(`
Usage: npm run cli test:live [options]

Run live tests against production API with curated test cases.

These test cases are hand-crafted based on real-world fraud patterns,
NOT generated by our detection algorithms (avoiding circular validation).

Options:
  -e, --endpoint <url>   API endpoint to test (default: https://your-worker.workers.dev/validate)
  -v, --verbose          Show detailed output for all tests
  -h, --help            Show this help message

Examples:
  npm run cli test:live
  npm run cli test:live --verbose
  npm run cli test:live --endpoint https://your-worker.workers.dev/signup
      `);
      return;
    }
  }

  await runTests(options.endpoint, options.verbose);
}
